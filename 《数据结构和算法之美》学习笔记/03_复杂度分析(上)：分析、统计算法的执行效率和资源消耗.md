# 复杂度分析(上)：分析、统计算法的执行效率和资源消耗

#### 一、为什么需要进行复杂度分析？
我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。

#### 二、大O复杂度表示法的由来

看下面的一段代码，来分析代码的执行时间：

```java
public int cal(int n){
  int sum = 0;
  int i = 1;
  for( ; i<=n; ++i){
    sum = sum +ｉ;
  }
  return sum;
}
```

从CPU的角度来看，这段代码的每一行代码都执行着类似的操作：读数据-运算-写数据。我们可以假设每行代码执行的时间都一样，为unit_time。

在这个基础之上，这段代码的执行是多少呢？执行第2,3行代码分别需要1个unit_time，第4,5是一个for循环，循环了n次，因此执行这个循环需要n个unit_time，所以这段代码的总执行时间为（n+2）* unit_time.可以看出，所有代码的执行时间T(n)与每一行代码的执行次数成正比。

即**T(n) = O(f(n))**
T(n)为所有代码执行的总时间，f(n)表示每行代码执行的次数总和，O表示代码的执行时间T(n)与f(n)表达式成正比。

#### 三、时间、空间复杂度表示法


 **1. 大O时间复杂度** 表示法并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，即代码执行时间的变化趋势。所以，也叫作渐进时间复杂度，简称时间复杂度。

 **分析时间复杂度的三个方法：**
 + 1）只关注循环执行次数最多的一段代码。

 大O复杂度表示法只是表示一种变化趋势，所以可以忽略掉公式中的常亮、低阶、系数，只需要记录一个最大阶的量级就可以了。

 + 2）加法法则：总复杂度等于量级最大的那段代码的复杂度

 直接看代码分析：

 ```java
 public int cal(int n){
   int sum_1 = 0;
   int p = 1;
   for( ; p<100; ++p){
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for( ; q<n; ++q){
     sum_2 = sum_2 + q;
   }

   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for( ; i<n; ++i){
     j = 1;
     for( ; j<=n; ++j){
       sum_3 = sum_3 + i*j;
     }
   }

   return sum_1 + sum_2 + sum_3;
 }
 ```

 这段代码有三个循环，第一个循环的时间复杂度为O(1),第二个循环的时间复杂度为O(n),第三个循环的时间复杂度为O(n*n),也就是n(n^2)。所以，最终这段代码的时间复杂度为O(n^2).



 **2. 大O空间复杂度** 表示算法存储空间与数据规模之间的增长关系。
